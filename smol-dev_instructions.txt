"# Automatic package installer for R

Inputs
env_name: A string representing the name of the Conda environment to be created or used.
pkg_input: A string or filename that specifies the packages to be installed and their sources. If a filename is provided, it should contain lines in the format package_name=source.

Objectives
Environment Setup: Create or use a specified Conda environment and install the R base package (r-base) if the environment doesn't exist.
Package Installation: Automatically install various types of packages—R packages, Conda packages, and Pip packages—into the specified Conda environment.
Error Handling and Logging: Keep track of which packages fail to install, log the installation process, and output a summary.

Features of the Function
Multi-Source Package Installation: Supports the installation of R packages from multiple sources like CRAN, Bioconductor, and GitHub.
Conda and Pip Support: Can install Python packages from both Conda and Pip repositories.
Batch Installation: Supports the installation of multiple packages by reading them from a file.
Dynamic Channel Lookup for Conda: Attempts to install Conda packages from multiple channels (conda-forge, r, bioconda) until successful.
Logging: Logs the installation process and any errors to an install.log file.
Error Reporting: Writes the names of failed R packages to a separate file called failed_r_packages.txt.
Debugging Support: Includes debug lines to print intermediate variables for troubleshooting.


Below are the detailed step-by-step instructions outlining what the `install_conda_pkgs` function does:

### Step 1: Initialize Variables
- `failed_pkgs`: An empty array to store the names of packages that fail to install.
- `env_exists`: A variable that will store whether the specified Conda environment already exists.
- `pkgs_r`: An empty string to store R package names and their sources in a named list format.
- `conda_pkgs` and `pip_pkgs`: Empty arrays to store the names of Conda and Pip packages, respectively.

### Step 2: Check If Conda Environment Exists
- Run the `conda env list` command to list all existing Conda environments.
- Use `awk` and `grep` to check if the specified environment (`env_name`) exists.
- If it doesn't exist, create a new Conda environment and install the `r-base` package.

### Step 3: Activate Conda Environment
- Activate the specified Conda environment using the `conda activate` command.

### Step 4: Read Package List
- Check if `pkg_input` is a filename or a string specifying a single package.
- If it's a filename, read the file line-by-line:
  - Skip lines starting with a `#` (comments).
  - Parse the package name (`key`) and source (`value`).
  - Add this information to the appropriate variables (`pkgs_r`, `conda_pkgs`, `pip_pkgs`).

### Step 5: Format R Packages List
- Remove the trailing comma from `pkgs_r`.
- Wrap the elements in `list()` to form a valid R named list.

### Step 6: Install R Packages
- Use `Rscript` to execute inline R code:
  - Iterate through the list of R packages (`pkgs_r`).
  - Check if the package is already installed.
  - If not, attempt to install it from the specified source (CRAN, Bioconductor, or GitHub).
  - Catch errors and update `failed_r_pkgs` if the installation fails.

### Step 7: Install Conda Packages
- Iterate through the `conda_pkgs` array:
  - Try to install each package from different channels (`conda-forge`, `r`, `bioconda`) until successful.
  - If the package fails to install from all channels, add it to `failed_pkgs`.

### Step 8: Install Pip Packages
- Iterate through the `pip_pkgs` array:
  - Try to install each package using Pip.
  - If the installation fails, add the package name to `failed_pkgs`.

### Step 9: Error Reporting and Logging
- Check the `failed_pkgs` array:
  - If it's not empty, print the names of the packages that failed to install and append this information to `install.log`.
  - If it's empty, print a success message and append it to `install.log`.

That covers the step-by-step execution of the `install_conda_pkgs` function. Each step is designed to handle a specific aspect of the package installation process, from environment setup to error reporting.
